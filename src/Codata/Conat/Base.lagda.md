---
description: |
  Conatural numbers.
---
<!--
```agda
open import 1Lab.Prelude hiding (zero; suc; _+_; _*_)

open import Data.Maybe.Base
open import Data.Bool.Base
open import Data.Dec.Base

open import Meta.Invariant

import Data.Nat.Base as Nat
```
-->
```agda
module Codata.Conat.Base where
```

# Conatural numbers

The **conatural numbers**, denoted $\Conat$, are the coinductive counterpart to the
[[natural numbers]]: rather than being generated by a pair of constructors
`zero : Nat`{.Agda} and `suc`{.Agda}, it is generated by a *destructor*
`force`{.Agda} that determines if the number is a zero or a successor.

```agda
mutual
  data Conat# : Type where
    zero# : Conat#
    suc# : Conat → Conat#

  record Conat : Type where
    coinductive
    field
      force : Conat#

open Conat
```

Like the natural numbers, the conaturals are equipped with `zero`{.Agda}
and a successor map.

```agda
zero : Conat
zero .force = zero#

suc : Conat → Conat
suc x .force = suc# x
```

This means that we can transform any natural number into a corresponding
conatural.

```agda
from-nat : Nat → Conat
from-nat Nat.zero = zero
from-nat (Nat.suc n) = suc (from-nat n)

from-nat# : Nat → Conat#
from-nat# Nat.zero = zero#
from-nat# (Nat.suc n) = suc# (from-nat n)
```

<!--
```agda
instance
  Number-Conat# : Number Conat#
  Number-Conat# .Number.Constraint _ = ⊤
  Number-Conat# .Number.fromNat n = from-nat# n

  Number-Conat : Number Conat
  Number-Conat .Number.Constraint _ = ⊤
  Number-Conat .Number.fromNat n = from-nat n
```
-->

However, *unlike* the natural numbers, the conaturals have an extra point
that always returns `suc#`{.Agda} when destructed. This point ends up acting
like a point in infinity, as it is larger than every single finite conatural!

```agda
∞ : Conat
∞ .force = suc# ∞
```

```agda
pred# : Conat# → Maybe Conat
pred# zero# = nothing
pred# (suc# x) = just x

pred : Conat → Maybe Conat
pred x = pred# (x .force)
```

## Corecursion principle

<!--
```agda
private variable
  ℓ : Level
  A : Type ℓ
```
-->

As coinductive types, the conatural numbers do not satisfy a recursion principle.
Instead, they have a **corecursion principle**, which lets us construct
rather than destruct an element of the type. In particular, we can extend
any map $f : A \to 1 + A$ to a map $f^{\infty} : A \to \Conat$ by repeatedly
calling $f$, and terminating once we see a `nothing`{.Agda}.

```agda
mutual
  Conat-corec# : (A → Maybe A) → Maybe A → Conat#
  Conat-corec# f nothing = zero#
  Conat-corec# f (just a) = suc# (Conat-corec f a)

  Conat-corec : (A → Maybe A) → A → Conat
  Conat-corec f a .force = Conat-corec# f (f a)
```

A more precise way to phrase this is to say that
$\operatorname{pred} \circ f^{\infty} = \id + f^\infty \circ f$; EG:
that $f^{\infty}$ is a **morphism of coalgebras**.

```agda
Conat-corec-pred#
  : ∀ {ℓ} {A : Type ℓ}
  → (f : A → Maybe A) (a : Maybe A)
  → pred# (Conat-corec# f a) ≡ (Conat-corec f <$> a)
Conat-corec-pred# f nothing = refl
Conat-corec-pred# f (just a) = refl

Conat-corec-pred
  : ∀ {ℓ} {A : Type ℓ}
  → (f : A → Maybe A) (a : A)
  → pred (Conat-corec f a) ≡ (Conat-corec f <$> f a)
Conat-corec-pred f a = Conat-corec-pred# f (f a)
```

## Bisimulation

<!-- [TODO: Reed M, 22/01/2025] Explain this -->

```agda
mutual
  data _≈#_ : Conat# → Conat# → Type where
    z≈z# : zero# ≈# zero#
    s≈s# : ∀ {x y} → x ≈ y → suc# x ≈# suc# y

  record _≈_ (x y : Conat) : Type where
    coinductive
    constructor bisim
    field
      force : x .force ≈# y .force

open _≈_
```

```agda
mutual
  ≈#-refl : ∀ {x} → x ≈# x
  ≈#-refl {x = zero#} = z≈z#
  ≈#-refl {x = suc# x} = s≈s# ≈-refl

  ≈-refl : ∀ {x} → x ≈ x
  ≈-refl .force = ≈#-refl


mutual
  ≈-to-path : ∀ {x y} → x ≈ y → x ≡ y
  ≈-to-path p i .force = ≈#-to-path (p .force) i

  ≈#-to-path : ∀ {x y} → x ≈# y → x ≡ y
  ≈#-to-path z≈z# i = zero#
  ≈#-to-path (s≈s# p) i = suc# (≈-to-path p i)

mutual
  ≈-to-pathp : ∀ {x y} → (p : x ≈ y) → PathP (λ i → x ≈ ≈-to-path p i) ≈-refl p
  ≈-to-pathp p i .force = ≈-to-pathp# (p .force) i

  ≈-to-pathp# : ∀ {x y} → (p : x ≈# y) → PathP (λ i → x ≈# ≈#-to-path p i) ≈#-refl p
  ≈-to-pathp# z≈z# i = z≈z#
  ≈-to-pathp# (s≈s# p) i = s≈s# (≈-to-pathp p i)
```

```agda
≈-identity-system : is-identity-system _≈_ (λ _ → ≈-refl)
≈-identity-system .to-path = ≈-to-path
≈-identity-system .to-path-over = ≈-to-pathp

≈#-identity-system : is-identity-system _≈#_ (λ _ → ≈#-refl)
≈#-identity-system .to-path = ≈#-to-path
≈#-identity-system .to-path-over = ≈-to-pathp#
```

<!--
```agda
instance
  Extensionality-Conat : Extensional Conat lzero
  Extensionality-Conat .Pathᵉ = _≈_
  Extensionality-Conat .reflᵉ _ = ≈-refl
  Extensionality-Conat .idsᵉ = ≈-identity-system

  Extensional-Conat# : Extensional Conat# lzero
  Extensional-Conat# .Pathᵉ = _≈#_
  Extensional-Conat# .reflᵉ _ = ≈#-refl
  Extensional-Conat# .idsᵉ = ≈#-identity-system
```
-->

```agda
mutual
  ≈-is-prop : ∀ {x y} → is-prop (x ≈ y)
  ≈-is-prop p q i .force = ≈#-is-prop (p .force) (q .force) i

  ≈#-is-prop : ∀ {x y} → is-prop (x ≈# y)
  ≈#-is-prop z≈z# z≈z# i = z≈z#
  ≈#-is-prop (s≈s# p) (s≈s# q) i = s≈s# (≈-is-prop p q i)
```

```agda
Conat-is-hlevel : ∀ n → is-hlevel Conat (Nat.suc (Nat.suc n))
Conat-is-hlevel n =
  identity-system→hlevel (Nat.suc n) ≈-identity-system λ _ _ →
    is-prop→is-hlevel-suc ≈-is-prop

Conat#-is-hlevel : ∀ n → is-hlevel Conat# (Nat.suc (Nat.suc n))
Conat#-is-hlevel n =
  identity-system→hlevel (Nat.suc n) ≈#-identity-system λ _ _ →
    is-prop→is-hlevel-suc ≈#-is-prop
```

```agda
suc-peel# : ∀ {x y} → suc# x ≈# suc# y → x ≈ y
suc-peel# (s≈s# p) = p
```


## Ordering

```agda
mutual
  data _≤#_ : Conat# → Conat# → Type where
    0≤x# : ∀ {x} → zero# ≤# x
    s≤s# : ∀ {x y} → x ≤ y → suc# x ≤# suc# y

  record _≤_ (x y : Conat) : Type where
    coinductive
    field
      force : x .force ≤# y .force

open _≤_
```

## Arithmetic

<!-- [TODO: Reed M, 22/01/2025] Explain fused addition. -->

```agda
mutual
  fadd# : Conat# → Conat# → Conat → Conat#
  fadd# zero# zero# z = z .force
  fadd# zero# (suc# y) z = suc# (fadd 0 y z)
  fadd# (suc# x) zero# z = suc# (fadd x 0 z)
  fadd# (suc# x) (suc# y) z = suc# (fadd x y (suc z))

  fadd : Conat → Conat → Conat → Conat
  fadd x y z .force = fadd# (x .force) (y .force) z

_+#_ : Conat# → Conat# → Conat#
x +# y = fadd# x y 0

_+_ : Conat → Conat → Conat
x + y = fadd x y 0
```

<!-- [TODO: Reed M, 22/01/2025]
Explain the trick: basic idea is that we are going to compute 'x*y + z',
where z is a lazy accumulator.

Similar to a fused-multiply-and-add instruction, hence the name fmul.
-->

```agda
mutual
  fmul# : Conat# → Conat# → Conat → Conat#
  fmul# zero# y z = z .force
  fmul# (suc# x) zero# z = z .force
  fmul# (suc# x) (suc# y) z = suc# (fmul x y (fadd x y z)) -- (1 + x)(1 + y) + z = 1 + (xy + (x + y + z))

  fmul : Conat → Conat → Conat → Conat
  fmul x y z .force = fmul# (x .force) (y .force) z

_*#_ : Conat# → Conat# → Conat#
x *# y = fmul# x y 0

_*_ : Conat → Conat → Conat
x * y = fmul x y 0

```
